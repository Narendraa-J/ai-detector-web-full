// pages/api/detect-text.js
// Gemini Flash 2.5 + robust heuristic fallback for AI detection

export default async function handler(req, res) {
  if (req.method !== "POST") return res.status(405).json({ error: "POST only" });
  const { text } = req.body || {};
  if (!text || !text.trim()) return res.status(400).json({ error: "No text provided" });

  const key = process.env.GEMINI_API_KEY;

  // Heuristic fallback (much improved)
  const heuristic = (t) => {
    const s = t.trim();
    const words = s.split(/\s+/).filter(Boolean);
    const wordCount = Math.max(1, words.length);
    const sentences = s.split(/[.!?]+/).filter(Boolean);
    const sentenceCount = Math.max(1, sentences.length);

    // repetition score (n-gram repeats)
    const lower = s.toLowerCase();
    const tokens = lower.split(/\s+/);
    let repeats = 0;
    const seen = new Map();
    for (let i = 0; i < tokens.length; i++) {
      const gram = tokens[i];
      const p = seen.get(gram) || 0;
      if (p > 0) repeats++;
      seen.set(gram, p + 1);
    }

    const avgWordLen = words.reduce((a,b)=>a+b.length,0)/wordCount;
    const avgSentenceLen = wordCount / sentenceCount;
    const aiPhrases = ["in conclusion","therefore","thus","moreover","furthermore","as a result"];
    const phraseCount = aiPhrases.reduce((n,p)=>n + (lower.includes(p)?1:0), 0);

    // Combine signals (weights tuned)
    let score =
      0.30 * Math.min(1, repeats / 3) +
      0.22 * Math.max(0, (avgSentenceLen - 12) / 20) +
      0.18 * Math.max(0, (avgWordLen - 4) / 6) +
      0.22 * Math.min(1, phraseCount / 2) +
      0.08 * (s.length > 400 ? 0.5 : 0.0);

    score = Math.max(0, Math.min(1, score));
    return {
      ai_probability: parseFloat(score.toFixed(2)),
      explanation: "Heuristic fallback: combined repetition/length/phrases",
      fallback: true,
      details: { repeats, avgWordLen: parseFloat(avgWordLen.toFixed(2)), avgSentenceLen: parseFloat(avgSentenceLen.toFixed(2)), phraseCount }
    };
  };

  if (!key) {
    return res.json(heuristic(text));
  }

  try {
    // Call Gemini Flash 2.5
    const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${encodeURIComponent(key)}`;
    const body = {
      contents: [{ parts: [{ text: `You are an analyst. Evaluate whether the following text was likely generated by AI. Return plain JSON containing "ai_probability":0.0-1.0 (number) and "explanation": "short text". Do not add extra commentary.\n\nTEXT:\n${text}` }] }]
    };

    const r = await fetch(endpoint, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
    const textResp = await r.text();

    if (!r.ok) {
      // provider returned non-OK: fallback
      return res.json({ note: "Gemini returned error; using heuristic fallback", providerStatus: r.status, providerText: textResp, ...heuristic(text) });
    }

    // parse provider safely
    let parsed;
    try { parsed = textResp ? JSON.parse(textResp) : null; } catch (e) {
      // provider returned text (not JSON) — return that text in explanation
      return res.json({ ai_probability: null, explanation: textResp, providerRaw: textResp });
    }

    const reply = parsed?.candidates?.[0]?.content?.parts?.[0]?.text || "";
    // try extract probability number
    const m = reply.match(/ai_probability\s*[:=]\s*(0?\.\d+|1(\.0+)?)/i);
    const aiProb = m ? parseFloat(m[1]) : null;

    return res.json({ ai_probability: aiProb, explanation: reply, providerRaw: parsed });
  } catch (err) {
    console.error("detect-text error:", err);
    return res.json({ note: "Exception calling provider — heuristic used", ...heuristic(text) });
  }
}
